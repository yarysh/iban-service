package cmd

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"html/template"
	"os"
	"path"
	"regexp"
	"runtime"
	"strconv"
	"strings"
)

var rawRuleGroupRegexp = regexp.MustCompile(`\d+!?[nac]`)
var rawRulesPlaceholders = map[string]string{
	"n": "[0-9]",
	"a": "[A-Z]",
	"c": "[A-z0-9]",
}

var rawRuleCountryRegexp = regexp.MustCompile(`^[A-Z]{2}`)

type rule struct {
	Regex string
	Size  int
}

var rulesFileTpl = template.Must(template.New("rules").Parse(` 
// Code generated by go generate; DO NOT EDIT
// Use go generate ./iban/validator

package validator
import "regexp"
type Rule struct {
	Regex *regexp.Regexp
	Size  int
}
var Rules = map[string]Rule{
{{- range $country, $rule := . }}
	"{{$country}}": {regexp.MustCompile("{{$rule.Regex}}"), {{$rule.Size}}},
{{- end }}
}
`))

func getRawRulesFromFile(filePath string) ([]string, error) {
	srcFile, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer srcFile.Close()

	scanner := bufio.NewScanner(srcFile)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "IBAN structure") {
			continue
		}
		structs := strings.Split(line, "\t")
		if len(structs) > 2 {
			return structs[1:], nil
		}
	}
	if scanner.Err() != nil {
		return nil, scanner.Err()
	}
	return nil, fmt.Errorf("IBAN rules not found")
}

func convertRawRules(rawRules []string) (map[string]rule, error) {
	result := map[string]rule{}
	for _, rawRule := range rawRules {
		if len(rawRule) < 3 {
			return nil, fmt.Errorf("invalid raw rule: %s", rawRule)
		}
		countries := rawRuleCountryRegexp.FindAllString(rawRule, 1)
		if len(countries) != 1 {
			return nil, fmt.Errorf("invalid raw rule: %s, can't parse country", rawRule)
		}
		groups := rawRuleGroupRegexp.FindAllString(rawRule, -1)
		if len(groups) == 0 {
			return nil, fmt.Errorf("invalid raw rule: %s, can't parse groups", rawRule)
		}

		country := countries[0]
		regex := country
		size := len(country)
		for _, group := range groups {
			lengthStr := ""
			fixedLength := false
			for i := len(group) - 1; i >= 0; i-- {
				symbol := string(group[i])
				if symbol == "!" {
					fixedLength = true
				} else if r, ok := rawRulesPlaceholders[symbol]; ok {
					regex += r
				} else {
					_, err := strconv.Atoi(symbol)
					if err != nil {
						return nil, err
					}
					lengthStr = symbol + lengthStr
				}
			}

			length, err := strconv.Atoi(lengthStr)
			if err != nil {
				return nil, fmt.Errorf("can't generate valid regexp from raw rule: %s", rawRule)
			}

			size += length

			if length > 1 && fixedLength {
				regex += fmt.Sprintf("{%d}", length)
			} else if length > 1 {
				regex += fmt.Sprintf("{0,%d}", length)
			}
		}
		regex = fmt.Sprintf("^%s$", regex)
		_, err := regexp.Compile(regex)
		if err != nil {
			return nil, fmt.Errorf("can't generate valid regexp from raw rule: %s", rawRule)
		}
		result[country] = rule{Regex: regex, Size: size}
	}
	return result, nil
}

func genRulesCode(rules map[string]rule) ([]byte, error) {
	var tpl bytes.Buffer
	err := rulesFileTpl.Execute(&tpl, rules)
	if err != nil {
		return nil, err
	}
	return format.Source(tpl.Bytes())
}

func saveCodeToFile(filePath string, code []byte) error {
	outFile, err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer outFile.Close()

	_, err = outFile.Write(code)
	if err != nil {
		return err
	}
	return nil
}

type GenValidatorRulesCmd struct{}

func (cmd GenValidatorRulesCmd) Run(params []string) error {
	_, runFile, _, _ := runtime.Caller(0)
	currPath := path.Join(path.Dir(runFile))

	flagSet := flag.NewFlagSet("gen_validator_rules", flag.ExitOnError)
	src := flagSet.String(
		"src",
		path.Join(currPath, "../assets/swift_iban.txt"),
		"path for swift's rules file",
	)
	out := flagSet.String(
		"out",
		path.Join(currPath, "../validator/rules.go"),
		"path for a generated file with validation rules",
	)
	if err := flagSet.Parse(params); err != nil {
		return err
	}

	// Parse raw rules from swift file
	rawRules, err := getRawRulesFromFile(*src)
	if err != nil {
		return err
	}

	// Convert raw rules to regexp
	rules, err := convertRawRules(rawRules)
	if err != nil {
		return err
	}

	// Generate code for rules.go
	code, err := genRulesCode(rules)
	if err != nil {
		return err
	}

	// Save generated code to file
	err = saveCodeToFile(*out, code)
	if err != nil {
		return err
	}

	return nil
}
